"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var text_encoding_shim_1 = require("text-encoding-shim");
var crypto_1 = require("./crypto");
var dataRegex = /^0x(?:[\da-fA-F]{2})*$/;
var addressRegex = /^0x[\da-fA-F]{40}$/;
var addressLowerRegex = /^0x[\da-f]{40}$/;
var addressUpperRegex = /^0x[\dA-F]{40}$/;
var hashRegex = /^0x[\da-fA-F]{64}$/;
var quantityRegex = /^0x[1-9a-fA-F][\da-fA-F]*$/;
var chainIdRegex = /^\d+$/;
var textEncoder = new text_encoding_shim_1.TextEncoder('utf-8');
function isValidAddress(v) {
    return (addressLowerRegex.test(v) || addressUpperRegex.test(v) || v === address(v));
}
exports.isValidAddress = isValidAddress;
function address(v) {
    var stringified;
    try {
        if (typeof v === 'string' && addressRegex.test(v)) {
            stringified = v;
        }
        else {
            return address(data(v));
        }
    }
    catch (e) {
        throw new TypeError("address '" + v + "' is invalid");
    }
    if (stringified.startsWith('0x')) {
        stringified = stringified.substring(2);
    }
    stringified = stringified.toLowerCase();
    return ('0x' +
        __spread(crypto_1.keccak256(stringified).substring(2, 42)).map(function (bit, i) {
            return parseInt(bit, 16) >= 8
                ? stringified[i].toUpperCase()
                : stringified[i];
        })
            .join(''));
}
exports.address = address;
function data(v, length) {
    if (length === void 0) { length = -1; }
    var e_1, _a;
    if (typeof v === 'string') {
        if (dataRegex.test(v)) {
            if (length >= 0 && v.length !== length * 2 + 2) {
                throw new TypeError("data '" + v + "' is invalid, bad length");
            }
            return v;
        }
        return data(textEncoder.encode(v), length);
    }
    else if (v instanceof ArrayBuffer) {
        if (length >= 0 && v.byteLength !== length) {
            throw new TypeError("data '" + v + "' is invalid, bad length");
        }
        var out = '';
        try {
            for (var _b = __values(new Uint8Array(v)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var byte = _c.value;
                out += byte < 16 ? '0' + byte.toString(16) : byte.toString(16);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return '0x' + out;
    }
    else if (ArrayBuffer.isView(v)) {
        return data(v.buffer.slice(v.byteOffset, v.byteOffset + v.byteLength), length);
    }
    var stringified = v.toString();
    if (!dataRegex.test(stringified)) {
        throw new TypeError("data '" + v + "' is invalid");
    }
    if (length >= 0 && stringified.length !== length * 2 + 2) {
        throw new TypeError("data '" + v + "' is invalid, bad length");
    }
    return stringified;
}
exports.data = data;
function quantity(v) {
    if (typeof v === 'number') {
        if (Number.isInteger(v) && v > 0) {
            return '0x' + v.toString(16);
        }
        throw new TypeError("quantity '" + v + "' is invalid, must be integer");
    }
    else if (typeof v === 'string') {
        if (quantityRegex.test(v)) {
            return v;
        }
        throw new TypeError("quantity '" + v + "' is invalid");
    }
    return quantity(v.toString());
}
exports.quantity = quantity;
function block(v) {
    if (typeof v === 'number') {
        return '0x' + v.toString(16);
    }
    else if (typeof v === 'string') {
        if (hashRegex.test(v) || quantityRegex.test(v)) {
            return v;
        }
        throw new TypeError("block '" + v + "' is invalid");
    }
    return block(v.toString());
}
exports.block = block;
function tag(v) {
    if (typeof v === 'string' &&
        (v === 'pending' || v === 'latest' || v === 'earliest')) {
        return v;
    }
    try {
        return quantity(v);
    }
    catch (e) {
        throw new TypeError("tag '" + v + "' is invalid");
    }
}
exports.tag = tag;
function chainId(v) {
    if (typeof v === 'number') {
        if (Number.isInteger(v) && v > 0) {
            return v.toString();
        }
        throw new TypeError("chain-id '" + v + "' is invalid");
    }
    else if (typeof v === 'string') {
        if (chainIdRegex.test(v)) {
            return v;
        }
        throw new TypeError("chain-id '" + v + "' is invalid");
    }
    return chainId(v.toString());
}
exports.chainId = chainId;
