"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var IPFS = require("ipfs");
var IPFSFactory = require("ipfsd-ctl");
var Ipfs = (function () {
    function Ipfs(options) {
        this.options = options;
        this.node = new IPFS(__assign({ start: false }, options));
    }
    Ipfs.prototype.start = function () {
        var _this = this;
        if (this.getNodeStatus() === 'uninitalized') {
            this.node.on('error', function () {
            });
            return new Promise(function (resolve, reject) {
                _this.node.on('ready', function () {
                    _this.node.start(function (err) {
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                    });
                });
            });
        }
        return new Promise(function (resolve, reject) {
            _this.node.start(function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    };
    Ipfs.prototype.stop = function () {
        var _this = this;
        if (this.node && this.node.state.state() !== 'stopped') {
            return new Promise(function (resolve, reject) {
                _this.node.stop(function (err) {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
        return;
    };
    Ipfs.prototype.getNodeStatus = function () {
        if (this.node) {
            return this.node.state.state();
        }
        return 'uninitalized';
    };
    Ipfs.prototype.upload = function (data, options, cb) {
        var _this = this;
        var files;
        if (data instanceof ArrayBuffer) {
            if (ArrayBuffer.isView(data)) {
                files = new Buffer(data.buffer);
            }
            else {
                files = new Buffer(data);
            }
        }
        else if (typeof data === 'string') {
            files = Buffer.from(data);
        }
        else {
            files = data;
        }
        return new Promise(function (resolve, reject) {
            _this.node.files.add(files, options, function (err, res) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
    };
    Ipfs.prototype.download = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.node.files.cat(path, function (err, res) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
    };
    Ipfs.prototype.viewFiles = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.node.ls(path, function (err, res) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
    };
    Ipfs.prototype.downloadDirectory = function (path) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.node.files.get(path, function (err, res) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
    };
    Ipfs.prototype.uploadObject = function (obj, options) {
        var _this = this;
        var opts = {
            format: 'dag-cbor',
            hashAlg: ' sha2-256',
        };
        if (options) {
            if ('cid' in options) {
                opts = options;
            }
            else {
                opts = {
                    format: options.format ? options.format : 'dag-cbor',
                    hashAlg: options.hashAlg ? options.hashAlg : 'sha2-256',
                };
            }
        }
        return new Promise(function (resolve, reject) {
            _this.node.dag.put(obj, opts, function (err, res) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
    };
    Ipfs.prototype.downloadObject = function (cid) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.node.dag.get(cid, function (err, res) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
    };
    Ipfs.prototype.peers = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.node.swarm.peers(function (err, peers) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(peers);
                }
            });
        });
    };
    Ipfs.prototype.id = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.node.id(function (err, id) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(id);
                }
            });
        });
    };
    Ipfs.prototype.spawnDaemon = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            IPFSFactory.create({ type: 'proc' }).spawn({ exec: IPFS }, function (err, ipfsd) {
                if (err) {
                    throw err;
                }
                _this.daemon = ipfsd;
                resolve();
            });
        });
    };
    Ipfs.prototype.stopDaemon = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.daemon.stop(function (err) {
                if (err) {
                    reject(err);
                }
                else {
                    resolve();
                }
            });
        });
    };
    return Ipfs;
}());
exports.Ipfs = Ipfs;
exports.default = Ipfs;
