interface Meta<T> {
    once?: boolean;
    thisArg?: any;
}
interface Handler<T> {
    meta?: Meta<T>;
    fn(value: any, context: T): void;
}
declare class Subscription<T> {
    protected parent: Emitter;
    type: string;
    handler: Handler<T>;
    constructor(parent: Emitter, type: string, handler: Handler<T>);
    dispose(): void;
}
declare class Emitter<T = any> {
    context?: T | undefined;
    currentHandler: Handler<T> | null;
    private __handlers;
    constructor(context?: T | undefined);
    on(type: string, fn: (value: any, context: T) => void, meta?: Meta<T>): Subscription<T>;
    once(type: string, fn: (value: any, context: T) => void): Subscription<T>;
    list(type: string): Array<Handler<T>>;
    disposeOf(type: string, fn: Function): void;
    disposeOfAll(type?: string): void;
    emit(type: string, value?: any): void;
    protected __emitToHandler(handler: Handler<T>, type: string, value?: any): void;
}
export { Emitter, Subscription, Handler, Meta };
