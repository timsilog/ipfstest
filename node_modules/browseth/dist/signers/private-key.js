"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_1 = require("crypto");
var ethereumjs_util_1 = require("ethereumjs-util");
var pbkdf2_1 = require("pbkdf2");
var rlp_1 = require("rlp");
var scrypt = require("scrypt-async");
var secp256k1_1 = require("secp256k1");
var uuidv4 = require("uuid/v4");
var crypto_2 = require("../crypto");
var PrivateKey = (function () {
    function PrivateKey(privKey) {
        if (typeof privKey === 'string') {
            this.privateKey = Buffer.from(privKey.replace('0x', ''), 'hex');
            return;
        }
        this.privateKey = privKey;
    }
    PrivateKey.fromV3 = function (keystore, pw) {
        return __awaiter(this, void 0, void 0, function () {
            var parsedKeystore, derivedKey, kdfparams, ciphertext, mac, decipher, seed;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        parsedKeystore = JSON.parse((typeof keystore === 'string'
                            ? keystore
                            : JSON.stringify(keystore)).toLowerCase());
                        if (parsedKeystore.version !== 3) {
                            throw new Error('Not a V3 wallet');
                        }
                        kdfparams = parsedKeystore.crypto.kdfparams;
                        if (!(parsedKeystore.crypto.kdf === 'pbkdf2')) return [3, 2];
                        return [4, pbkdf2Async(Buffer.from(pw), Buffer.from(kdfparams.salt, 'hex'), kdfparams.c || 262144, kdfparams.dklen, 'sha256')];
                    case 1:
                        derivedKey = _a.sent();
                        return [3, 5];
                    case 2:
                        if (!(parsedKeystore.crypto.kdf === 'scrypt')) return [3, 4];
                        return [4, scryptAsync(Buffer.from(pw), Buffer.from(kdfparams.salt, 'hex'), {
                                N: kdfparams.n || 262144,
                                r: kdfparams.r,
                                p: kdfparams.p,
                                dkLen: kdfparams.dklen,
                            })];
                    case 3:
                        derivedKey = _a.sent();
                        return [3, 5];
                    case 4: throw new Error('Unsupported kdf');
                    case 5:
                        ciphertext = Buffer.from(parsedKeystore.crypto.ciphertext, 'hex');
                        mac = crypto_2.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));
                        if (mac !== parsedKeystore.crypto.mac) {
                            throw new Error('Macs do not match. Check password');
                        }
                        decipher = crypto_1.createDecipheriv(parsedKeystore.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(parsedKeystore.crypto.cipherparams.iv, 'hex'));
                        seed = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
                        return [2, new PrivateKey(seed)];
                }
            });
        });
    };
    PrivateKey.fromHex = function (raw) {
        return new PrivateKey(Buffer.from(raw.replace('0x', ''), 'hex'));
    };
    PrivateKey.fromMnemonic = function (phrase, password) {
        return __awaiter(this, void 0, void 0, function () {
            var key;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, pbkdf2Async(typeof phrase === 'string' ? phrase : phrase.join(' '), password ? "mnemonic" + password : 'mnemonic', 2048, 64, 'SHA512')];
                    case 1:
                        key = _a.sent();
                        return [2, new PrivateKey(key)];
                }
            });
        });
    };
    PrivateKey.fromRandomBytes = function () {
        return new PrivateKey(crypto_1.randomBytes(32));
    };
    PrivateKey.prototype.account = function () {
        return Promise.resolve(this.toAddress());
    };
    PrivateKey.prototype.signTransaction = function (_a) {
        var _b = _a.nonce, nonce = _b === void 0 ? '0x' : _b, _c = _a.gasPrice, gasPrice = _c === void 0 ? '0x1' : _c, _d = _a.gas, gas = _d === void 0 ? '0x5208' : _d, _e = _a.to, to = _e === void 0 ? '0x' : _e, _f = _a.value, value = _f === void 0 ? '0x' : _f, _g = _a.data, data = _g === void 0 ? '0x' : _g, _h = _a.chainId, chainId = _h === void 0 ? 0x1 : _h;
        var raw = [
            ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(nonce)),
            ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(gasPrice)),
            ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(gas)),
            ethereumjs_util_1.toBuffer(to),
            ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(value)),
            ethereumjs_util_1.toBuffer(data),
        ];
        var sig = secp256k1_1.sign(crypto_2.keccak256(rlp_1.encode(raw.concat(chainId > 0
            ? [
                ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(chainId)),
                Buffer.from([]),
                Buffer.from([]),
            ]
            : []))), this.privateKey);
        return Promise.resolve('0x' +
            rlp_1.encode(raw.concat(ethereumjs_util_1.stripZeros(ethereumjs_util_1.toBuffer(sig.recovery + 27 + (chainId > 0 ? chainId * 2 + 8 : 0))), ethereumjs_util_1.stripZeros(sig.signature.slice(0, 32)), ethereumjs_util_1.stripZeros(sig.signature.slice(32, 64)))).toString('hex'));
    };
    PrivateKey.prototype.signMessage = function (message) {
        var hash = crypto_2.keccak256('\u0019Ethereum Signed Message:\n' + message.length.toString() + message);
        var sig = secp256k1_1.sign(hash, this.privateKey);
        return Promise.resolve('0x' + Buffer.from(__spread(sig.signature, [sig.recovery + 27])).toString('hex'));
    };
    PrivateKey.prototype.toString = function () {
        return "" + this.privateKey.toString('hex');
    };
    PrivateKey.prototype.toV3 = function (pw, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.salt, salt = _c === void 0 ? crypto_1.randomBytes(32) : _c, _d = _b.iv, iv = _d === void 0 ? crypto_1.randomBytes(16) : _d, _e = _b.uuid, uuid = _e === void 0 ? crypto_1.randomBytes(16) : _e, _f = _b.kdf, kdf = _f === void 0 ? 'scrypt' : _f, _g = _b.cipher, cipher = _g === void 0 ? 'aes-128-ctr' : _g, _h = _b.dklen, dklen = _h === void 0 ? 32 : _h, _j = _b.c, c = _j === void 0 ? 262144 : _j, _k = _b.n, n = _k === void 0 ? 262144 : _k, _l = _b.r, r = _l === void 0 ? 8 : _l, _m = _b.p, p = _m === void 0 ? 1 : _m;
        return __awaiter(this, void 0, void 0, function () {
            var kdfparams, derivedKey, ciph, ciphertext, mac;
            return __generator(this, function (_o) {
                switch (_o.label) {
                    case 0:
                        kdfparams = {
                            dklen: dklen,
                            salt: salt.toString('hex'),
                        };
                        if (!(kdf === 'pbkdf2')) return [3, 2];
                        kdfparams.c = c;
                        kdfparams.prf = 'hmac-sha256';
                        return [4, pbkdf2Async(Buffer.from(pw), salt, kdfparams.c, kdfparams.dklen, 'sha256')];
                    case 1:
                        derivedKey = _o.sent();
                        return [3, 5];
                    case 2:
                        if (!(kdf === 'scrypt')) return [3, 4];
                        kdfparams.n = n;
                        kdfparams.r = r;
                        kdfparams.p = p;
                        return [4, scryptAsync(Buffer.from(pw), salt, {
                                N: kdfparams.n,
                                r: kdfparams.r,
                                p: kdfparams.p,
                                dkLen: kdfparams.dklen,
                            })];
                    case 3:
                        derivedKey = _o.sent();
                        return [3, 5];
                    case 4: throw new Error('Unsupported kdf');
                    case 5:
                        ciph = crypto_1.createCipheriv(cipher, derivedKey.slice(0, 16), iv);
                        if (!ciph) {
                            throw new Error('Unsupported cipher');
                        }
                        ciphertext = Buffer.concat([
                            ciph.update(this.privateKey),
                            ciph.final(),
                        ]);
                        mac = crypto_2.keccak256(Buffer.concat([derivedKey.slice(16, 32), ciphertext]));
                        return [2, JSON.stringify({
                                version: 3,
                                id: uuidv4({ random: uuid }),
                                address: this.toAddress(),
                                crypto: {
                                    ciphertext: ciphertext.toString('hex'),
                                    cipherparams: {
                                        iv: iv.toString('hex'),
                                    },
                                    cipher: cipher,
                                    kdf: kdf,
                                    kdfparams: kdfparams,
                                    mac: mac,
                                },
                            })];
                }
            });
        });
    };
    PrivateKey.prototype.getKeyStoreFileName = function (date) {
        if (date === void 0) { date = new Date(); }
        return "UTC--" + date.getUTCFullYear() + "-" + ('0' +
            (date.getUTCMonth() + 1)).slice(-2) + "-" + ('0' + date.getUTCDate()).slice(-2) + "T" + ('0' + date.getUTCHours()).slice(-2) + "-" + ('0' + date.getUTCMinutes()).slice(-2) + "-" + ('0' + date.getUTCSeconds()).slice(-2) + "." + ('00' + date.getUTCMilliseconds()).slice(-3) + "Z--" + this.toAddress().slice(2);
    };
    PrivateKey.prototype.toAddress = function () {
        var pubKey = secp256k1_1.publicKeyCreate(this.privateKey, false).slice(1);
        if (pubKey.length !== 64) {
            throw new Error("invalid PublicKey<" + pubKey + ">");
        }
        return '0x' + crypto_2.keccak256(pubKey).slice(-40);
    };
    return PrivateKey;
}());
exports.PrivateKey = PrivateKey;
function pbkdf2Async(password, salt, iterations, keylen, digest) {
    return new Promise(function (resolve, reject) {
        pbkdf2_1.pbkdf2(password, salt, iterations, keylen, digest, function (err, res) {
            if (err) {
                reject(err);
            }
            else {
                resolve(res);
            }
        });
    });
}
function scryptAsync(password, salt, options) {
    return new Promise(function (resolve) {
        scrypt(password, salt, options, resolve);
    }).then(function (arr) { return Buffer.from(arr); });
}
