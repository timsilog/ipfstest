"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Abi = require("ethereumjs-abi");
function createAbiCodec(jsonInterface) {
    var abi = {
        constructor: {
            encode: function (bytecode) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                return '0x' + bytecode;
            },
        },
        event: {},
        function: {},
    };
    jsonInterface.forEach(function (element) {
        switch (element.type) {
            case 'constructor': {
                var types_1 = element.inputs.map(function (i) { return i.type; });
                abi.constructor = __assign({}, element, { encode: function (bytecode) {
                        var params = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                            params[_i - 1] = arguments[_i];
                        }
                        return ('0x' + bytecode + Abi.rawEncode(types_1, params).toString('hex'));
                    } });
                break;
            }
            case 'event': {
                var types = element.inputs.map(function (i) { return i.type; });
                var signature_1 = Abi.eventID(element.name, types).toString('hex');
                var codec = __assign({}, element, { signature: signature_1,
                    encode: function (topics) {
                        var encodedTopics = [];
                        if (!element.anonymous) {
                            encodedTopics.push('0x' + signature_1);
                        }
                        element.inputs.forEach(function (i) {
                            if (i.indexed && topics[i.name]) {
                                if (Array.isArray(topics[i.name])) {
                                    var encodedTopicArray_1 = [];
                                    topics[i.name].forEach(function (t) {
                                        var encodedTopicElement = Abi.rawEncode([i.type], [t]).toString('hex');
                                        encodedTopicArray_1.push('0x' +
                                            (encodedTopicElement.length > 64
                                                ? Abi.soliditySHA3([i.type], [t]).toString('hex')
                                                : encodedTopicElement));
                                    });
                                    encodedTopics.push(encodedTopicArray_1);
                                }
                                else {
                                    var encodedTopic = Abi.rawEncode([i.type], [topics[i.name]]).toString('hex');
                                    encodedTopics.push('0x' +
                                        (encodedTopic.length > 64
                                            ? Abi.soliditySHA3([i.type], [topics[i.name]]).toString('hex')
                                            : encodedTopic));
                                }
                            }
                            else {
                                encodedTopics.push(null);
                            }
                        });
                        while (encodedTopics.length >= 0 &&
                            encodedTopics[encodedTopics.length - 1] == null) {
                            encodedTopics = encodedTopics.slice(0, -1);
                        }
                        return encodedTopics;
                    },
                    decode: function (log) {
                        if (!element.anonymous) {
                            log.topics.shift();
                        }
                        var indexedInputs = element.inputs
                            .map(function (v, i) { return ({ v: v, i: i }); })
                            .filter(function (_a) {
                            var v = _a.v;
                            return v.indexed;
                        });
                        var indexedDecoded = indexedInputs.map(function (_a, i) {
                            var v = _a.v;
                            return Abi.rawDecode([
                                v.type === 'string' || v.type === 'bytes'
                                    ? 'bytes32'
                                    : v.type,
                            ], Buffer.from(log.topics[i].replace('0x', ''), 'hex'))[0];
                        });
                        var unIndexedInputs = element.inputs
                            .map(function (v, i) { return ({ v: v, i: i }); })
                            .filter(function (_a) {
                            var v = _a.v;
                            return !v.indexed;
                        });
                        var unIndexedDecoded = Abi.rawDecode(unIndexedInputs.map(function (_a) {
                            var v = _a.v;
                            return v.type;
                        }), Buffer.from(log.data.replace('0x', ''), 'hex'));
                        return __assign({}, indexedInputs.reduce(function (a, _a, i) {
                            var v = _a.v, originalIndex = _a.i;
                            var _b;
                            return (__assign({}, a, (_b = {}, _b[originalIndex] = indexedDecoded[i], _b[v.name] = indexedDecoded[i], _b)));
                        }, {}), unIndexedInputs.reduce(function (a, _a, i) {
                            var v = _a.v, originalIndex = _a.i;
                            var _b;
                            return (__assign({}, a, (_b = {}, _b[originalIndex] = unIndexedDecoded[i], _b[v.name] = unIndexedDecoded[i], _b)));
                        }, {}));
                    } });
                abi.event[element.name] = codec;
                abi.event[signature_1] = codec;
                break;
            }
            case 'function': {
                var iTypes_1 = element.inputs.map(function (i) { return i.type; });
                var oTypes_1 = element.outputs.map(function (i) { return i.type; });
                var signature_2 = Abi.methodID(element.name, iTypes_1).toString('hex');
                var codec = __assign({}, element, { signature: signature_2,
                    encode: function () {
                        var params = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            params[_i] = arguments[_i];
                        }
                        return ('0x' + signature_2 + Abi.rawEncode(iTypes_1, params).toString('hex'));
                    },
                    decode: function (raw) {
                        var decoded = Abi.rawDecode(oTypes_1, Buffer.from(raw.replace('0x', ''), 'hex')).map(function (v, i) { return (oTypes_1[i] === 'address' ? '0x' + v : v); });
                        return decoded.length === 1 ? decoded[0] : decoded;
                    } });
                abi.function[element.name] = codec;
                abi.function[signature_2] = codec;
                break;
            }
        }
    });
    return abi;
}
exports.createAbiCodec = createAbiCodec;
