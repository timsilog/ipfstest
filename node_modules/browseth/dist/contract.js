"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var abi_1 = require("./abi");
var crypto_1 = require("./crypto");
var Contract = (function () {
    function Contract(wallet, jsonInterface, options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.wallet = wallet;
        this.options = options;
        this.abi = abi_1.createAbiCodec(jsonInterface);
        this.event = Object.keys(this.abi.event)
            .map(function (k) { return _this.abi.event[k]; })
            .reduce(function (a, v) {
            var _a;
            var codec = function (topics) {
                if (topics === void 0) { topics = {}; }
                var encodedTopics = v.encode(topics);
                return {
                    logs: function (fromBlock, toBlock, address) {
                        if (fromBlock === void 0) { fromBlock = 'latest'; }
                        if (toBlock === void 0) { toBlock = 'latest'; }
                        return _this.wallet.rpc
                            .send('eth_getLogs', {
                            fromBlock: crypto_1.toHex(fromBlock),
                            toBlock: crypto_1.toHex(toBlock),
                            address: address ? address : _this.options.address,
                            topics: encodedTopics,
                        })
                            .then(function (logs) {
                            return logs.map(function (log) { return (__assign({}, log, { decodedTopics: v.decode(log) })); });
                        });
                    },
                };
            };
            return __assign({}, a, (_a = {}, _a[v.name] = codec, _a[v.signature] = codec, _a));
        }, {});
        this.function = Object.keys(this.abi.function)
            .map(function (k) { return _this.abi.function[k]; })
            .reduce(function (a, v) {
            var _a;
            var codec = function () {
                var params = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    params[_i] = arguments[_i];
                }
                var data = v.encode.apply(v, __spread(params));
                return {
                    batch: {
                        send: function (_a) {
                            var _b = _a.transaction, transaction = _b === void 0 ? {} : _b, cb = _a.cb;
                            return _this.wallet.batch.send(__assign({ to: _this.options.address }, transaction, { data: data,
                                cb: cb }));
                        },
                        call: function (_a) {
                            var _b = _a.transaction, transaction = _b === void 0 ? {} : _b, _c = _a.block, block = _c === void 0 ? 'latest' : _c, cb = _a.cb;
                            return _this.wallet.batch.call(__assign({ to: _this.options.address }, transaction, { data: data }), block, cb);
                        },
                        gas: function (_a) {
                            var _b = _a.transaction, transaction = _b === void 0 ? {} : _b, _c = _a.block, block = _c === void 0 ? 'latest' : _c, cb = _a.cb;
                            return _this.wallet.batch.gas(__assign({ to: _this.options.address }, transaction, { data: data }), block, cb);
                        },
                    },
                    send: function (transaction) {
                        if (transaction === void 0) { transaction = {}; }
                        return _this.wallet.send(__assign({ to: _this.options.address }, transaction, { data: data }));
                    },
                    call: function (transaction, block) {
                        if (transaction === void 0) { transaction = {}; }
                        if (block === void 0) { block = 'latest'; }
                        return _this.wallet
                            .call(__assign({ to: _this.options.address }, transaction, { data: data }), block)
                            .then(function (raw) { return v.decode(raw); });
                    },
                    gas: function (transaction, block) {
                        if (transaction === void 0) { transaction = {}; }
                        if (block === void 0) { block = 'latest'; }
                        return _this.wallet.gas(__assign({ to: _this.options.address }, transaction, { data: data }), block);
                    },
                };
            };
            return __assign({}, a, (_a = {}, _a[v.name] = codec, _a[v.signature] = codec, _a));
        }, {});
    }
    Contract.prototype.deploy = function () {
        var _this = this;
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var _a;
        if (this.options.bytecode &&
            typeof this.abi.constructor.encode === 'function') {
            var data_1 = (_a = this.abi.constructor).encode.apply(_a, __spread([this.options.bytecode], params));
            return {
                send: function (transaction) {
                    if (transaction === void 0) { transaction = {}; }
                    return _this.wallet.send(__assign({ to: _this.options.address }, transaction, { data: data_1 }));
                },
                gas: function (transaction, block) {
                    if (transaction === void 0) { transaction = {}; }
                    if (block === void 0) { block = 'latest'; }
                    return _this.wallet.gas(__assign({ to: _this.options.address }, transaction, { data: data_1 }), block);
                },
            };
        }
        throw new Error('Must have bytecode and a constructor jsonInterface element to deploy');
    };
    Object.defineProperty(Contract.prototype, "e", {
        get: function () {
            return this.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contract.prototype, "f", {
        get: function () {
            return this.function;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Contract.prototype, "methods", {
        get: function () {
            return this.function;
        },
        enumerable: true,
        configurable: true
    });
    return Contract;
}());
exports.Contract = Contract;
