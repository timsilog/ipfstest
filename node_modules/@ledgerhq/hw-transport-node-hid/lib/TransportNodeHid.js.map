{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["defer","resolve","reject","promise","success","failure","Error","TransportNodeHid","device","ledgerTransport","timeout","debug","exchangeStack","apdu","ledgerWrap","channel","command","packetSize","sequenceIdx","offset","tmp","Buffer","alloc","writeUInt16BE","length","blockSize","result","concat","slice","ledgerUnwrap","data","responseLength","response","deferred","exchangeTimeout","transport","setTimeout","push","processNextExchange","send","console","log","content","toString","i","write","recv","read","err","res","buffer","from","performExchange","offsetSent","firstReceived","toReceive","received","sendPart","receivePart","block","paddingSize","padding","fill","then","resultBin","size","clearTimeout","shift","close","path","HID","isSupported","list","map","d","listen","observer","unsubscribed","devices","descriptor","next","type","events","stop","onAdd","onRemove","on","unsubscribe","removeListener"],"mappings":"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","file":"TransportNodeHid.js","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport Transport, { TransportError } from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport getDevices from \"./getDevices\";\nimport listenDevices from \"./listenDevices\";\n\n// FIXME drop\ntype Defer<T> = {\n  promise: Promise<T>,\n  resolve: T => void,\n  reject: any => void\n};\nfunction defer<T>(): Defer<T> {\n  let resolve, reject;\n  let promise = new Promise(function(success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw new Error(\"defer() error\"); // this never happens and is just to make flow happy\n  return { promise, resolve, reject };\n}\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-u2f\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHid extends Transport<string> {\n  device: HID.HID;\n  ledgerTransport: boolean;\n  timeout: number;\n  debug: boolean;\n  exchangeStack: Array<*>;\n\n  constructor(\n    device: HID.HID,\n    ledgerTransport: boolean = true,\n    timeout: number = 0,\n    debug: boolean = false\n  ) {\n    super();\n    this.device = device;\n    this.ledgerTransport = ledgerTransport;\n    this.timeout = timeout;\n    this.exchangeStack = [];\n    this.debug = debug;\n  }\n\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof HID.HID === \"function\");\n\n  static list = (): Promise<string[]> =>\n    Promise.resolve(getDevices().map(d => d.path));\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<string>>\n  ): Subscription => {\n    let unsubscribed = false;\n    Promise.resolve(getDevices()).then(devices => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const descriptor: string = device.path;\n          observer.next({ type: \"add\", descriptor, device });\n        }\n      }\n    });\n    const { events, stop } = listenDevices();\n\n    const onAdd = device => {\n      observer.next({ type: \"add\", descriptor: device.path, device });\n    };\n    const onRemove = device => {\n      observer.next({ type: \"remove\", descriptor: device.path, device });\n    };\n    events.on(\"add\", onAdd);\n    events.on(\"remove\", onRemove);\n    function unsubscribe() {\n      unsubscribed = true;\n      events.removeListener(\"add\", onAdd);\n      events.removeListener(\"remove\", onRemove);\n      stop();\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   */\n  static async open(path: string) {\n    return Promise.resolve(new TransportNodeHid(new HID.HID(path)));\n  }\n\n  exchange(apdu: Buffer): Promise<Buffer> {\n    function ledgerWrap(channel, command, packetSize) {\n      let sequenceIdx = 0;\n      let offset = 0;\n\n      let tmp = Buffer.alloc(7);\n      tmp.writeUInt16BE(channel, 0);\n      tmp[2] = 0x05; // TAG_APDU\n      tmp.writeUInt16BE(sequenceIdx, 3);\n      sequenceIdx++;\n      tmp.writeUInt16BE(command.length, 5);\n      let blockSize =\n        command.length > packetSize - 7 ? packetSize - 7 : command.length;\n      let result = Buffer.concat(\n        [tmp, command.slice(offset, offset + blockSize)],\n        blockSize + 7\n      );\n      offset += blockSize;\n      while (offset !== command.length) {\n        tmp = Buffer.alloc(5);\n        tmp.writeUInt16BE(channel, 0);\n        tmp[2] = 0x05; // TAG_APDU\n        tmp.writeUInt16BE(sequenceIdx, 3);\n        sequenceIdx++;\n        blockSize =\n          command.length - offset > packetSize - 5\n            ? packetSize - 5\n            : command.length - offset;\n        result = Buffer.concat(\n          [result, tmp, command.slice(offset, offset + blockSize)],\n          result.length + blockSize + 5\n        );\n        offset += blockSize;\n      }\n      return result;\n    }\n\n    function ledgerUnwrap(channel, data, packetSize) {\n      let offset = 0;\n      let responseLength;\n      let sequenceIdx = 0;\n      let response;\n      if (typeof data === \"undefined\" || data.length < 7 + 5) {\n        return;\n      }\n      if (data[offset++] !== channel >> 8) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (data[offset++] !== (channel & 0xff)) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (data[offset++] !== 0x05) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (data[offset++] !== 0x00) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n      if (data[offset++] !== 0x00) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n      responseLength = (data[offset++] & 0xff) << 8;\n      responseLength |= data[offset++] & 0xff;\n      if (data.length < 7 + responseLength) {\n        return;\n      }\n      let blockSize =\n        responseLength > packetSize - 7 ? packetSize - 7 : responseLength;\n      response = data.slice(offset, offset + blockSize);\n      offset += blockSize;\n      while (response.length !== responseLength) {\n        sequenceIdx++;\n        if (offset === data.length) {\n          return;\n        }\n        if (data[offset++] !== channel >> 8) {\n          throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n        }\n        if (data[offset++] !== (channel & 0xff)) {\n          throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n        }\n        if (data[offset++] !== 0x05) {\n          throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n        }\n        if (data[offset++] !== sequenceIdx >> 8) {\n          throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n        }\n        if (data[offset++] !== (sequenceIdx & 0xff)) {\n          throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n        }\n        blockSize =\n          responseLength - response.length > packetSize - 5\n            ? packetSize - 5\n            : responseLength - response.length;\n        if (blockSize > data.length - offset) {\n          return;\n        }\n        response = Buffer.concat(\n          [response, data.slice(offset, offset + blockSize)],\n          response.length + blockSize\n        );\n        offset += blockSize;\n      }\n      return response;\n    }\n\n    const deferred = defer();\n    let exchangeTimeout;\n    let transport;\n    if (!this.ledgerTransport) {\n      transport = apdu;\n    } else {\n      transport = ledgerWrap(0x0101, apdu, 64);\n    }\n\n    if (this.timeout !== 0) {\n      exchangeTimeout = setTimeout(() => {\n        // Node.js supports timeouts\n        deferred.reject(new TransportError(\"timeout\", \"timeout\"));\n      }, this.timeout);\n    }\n\n    // enter the exchange wait list\n    this.exchangeStack.push(deferred);\n\n    if (this.exchangeStack.length === 1) {\n      const processNextExchange = () => {\n        // don't pop it now, to avoid multiple at once\n        const deferred = this.exchangeStack[0];\n\n        const send = content => {\n          if (this.debug) {\n            console.log(\"=>\" + content.toString(\"hex\"));\n          }\n          const data = [0x00];\n          for (let i = 0; i < content.length; i++) {\n            data.push(content[i]);\n          }\n          this.device.write(data);\n          return Promise.resolve(content.length);\n        };\n\n        const recv = () =>\n          new Promise((resolve, reject) =>\n            this.device.read((err, res) => {\n              if (err || !res) reject(err);\n              else {\n                const buffer = Buffer.from(res);\n                if (this.debug) {\n                  console.log(\"<=\" + buffer.toString(\"hex\"));\n                }\n                resolve(buffer);\n              }\n            })\n          );\n\n        const performExchange = () => {\n          let offsetSent = 0;\n          let firstReceived = true;\n          let toReceive = 0;\n\n          let received = Buffer.alloc(0);\n          const sendPart = () => {\n            if (offsetSent === transport.length) {\n              return receivePart();\n            }\n            const blockSize =\n              transport.length - offsetSent > 64\n                ? 64\n                : transport.length - offsetSent;\n            let block = transport.slice(offsetSent, offsetSent + blockSize);\n            const paddingSize = 64 - block.length;\n            if (paddingSize !== 0) {\n              let padding = Buffer.alloc(paddingSize).fill(0);\n              block = Buffer.concat(\n                [block, padding],\n                block.length + paddingSize\n              );\n            }\n            return send(block).then(() => {\n              offsetSent += blockSize;\n              return sendPart();\n            });\n          };\n\n          const receivePart = () => {\n            if (!this.ledgerTransport) {\n              return recv().then(result => {\n                received = Buffer.concat(\n                  [received, result],\n                  received.length + result.length\n                );\n                if (firstReceived) {\n                  firstReceived = false;\n                  if (received.length === 2 || received[0] !== 0x61) {\n                    return received;\n                  } else {\n                    toReceive = received[1];\n                    if (toReceive === 0) {\n                      toReceive = 256;\n                    }\n                    toReceive += 2;\n                  }\n                }\n                if (toReceive < 64) {\n                  return received;\n                } else {\n                  toReceive -= 64;\n                  return receivePart();\n                }\n              });\n            } else {\n              return recv().then(result => {\n                received = Buffer.concat(\n                  [received, result],\n                  received.length + result.length\n                );\n                const response = ledgerUnwrap(0x0101, received, 64);\n                if (typeof response !== \"undefined\") {\n                  return response;\n                } else {\n                  return receivePart();\n                }\n              });\n            }\n          };\n          return sendPart();\n        };\n\n        performExchange()\n          .then(result => {\n            let response,\n              resultBin = result;\n            if (!this.ledgerTransport) {\n              if (resultBin.length === 2 || resultBin[0] !== 0x61) {\n                response = resultBin;\n              } else {\n                let size = resultBin[1];\n                // fake T0\n                if (size === 0) {\n                  size = 256;\n                }\n                response = resultBin.slice(2);\n              }\n            } else {\n              response = resultBin;\n            }\n            // build the response\n            if (this.timeout !== 0) {\n              clearTimeout(exchangeTimeout);\n            }\n            return response;\n          })\n          .then(\n            response => {\n              // consume current promise\n              this.exchangeStack.shift();\n\n              // schedule next exchange\n              if (this.exchangeStack.length > 0) {\n                processNextExchange();\n              }\n              return response;\n            },\n            (err: Error) => {\n              if (this.timeout !== 0) {\n                clearTimeout(exchangeTimeout);\n              }\n              throw err;\n            }\n          )\n          // plug to deferred\n          .then(deferred.resolve, deferred.reject);\n      };\n\n      // schedule next exchange\n      processNextExchange();\n    }\n\n    // the exchangeStack will process the promise when possible\n    return deferred.promise;\n  }\n\n  setScrambleKey() {}\n\n  close(): Promise<void> {\n    this.device.close();\n    return Promise.resolve();\n  }\n}\n"]}